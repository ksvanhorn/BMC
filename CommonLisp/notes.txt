NOTATION
--------

dot: inner product of two tensors
^2: synonym for sqr
^1/2: synonym for sqrt
^-1/2
^-1: synonym for unary /
^-2: (^-2 x) == (^ x -2)
@^2: ^2 applied elementwise to an array
@^1/2: ^1/2 applied elementwise
@^-1/2
@^-1: ^-1 applied elementwise to an array
@^-2: ^-2 applied elementwise to an array
@+
@-
@*
@/
diag_mat
o* outer product
o^2 self outer product
$* multiply array by scalar
q@sum: quantified elementwise sum of arrays
rmat: matrix formed by stacking rows
qrmat: quantified form of rmat


TODO
----

Handle quantifiers having non-trivial filters when printing out expressions.

+Add update parameters to class.
Generation of update
Computation of log proposal density


- Draw from joint distribution.
- Make copy of sampler object.
- Do update on copy.
- Compute ljd_new - ljd_old + log_proposal_density_new - log_proposal_density_old
- Compute given acceptance ratio
- Compare.

- CHECK THAT log acceptance factor DOES NOT DEPEND ON ANY VARS DECLARED IN
  A LET ENCLOSING THE M-H RELATION (other than index variables?)
- For updates, need to check that ranges of enclosing for loops and tests
  of enclosing if-then-else's have no dependence on vars being updated.
- Need to fix TestUpdate_FOO(MyModel x, double tol) to include parameters
  for vars of any enclosing let's and loops used in the update.

(write-rel-draw <rel> &optional <let-needs-brackets>)
(write-ljd-accum-rel <accum-var-name> <rel> <let-needs-brackets> <var-name-pfx>)

// Overall
(write-test-updates <class-name> <update-names>
  &optional <write-test-update-fct> )
(write-test-is-dag-update <class-name> <update-name> <rel> <model-vars>
  <assigned-vars> <dim-fct> &optional <write-body>)
- (write-rel-draw-with-dag-test <rel> <model-vars> <dim-fct>)
  - (write-assigned-test <rel> <dim-fct>)
- (args-vars-names <mdl>)
- (model-variables-assigned-in <rel>)
- (model->dim-fct <mdl>)

// For a Gibbs update:
(write-test-gibbs-update <class-name> <update-name>)
(write-log-draw-density-of-update <class-name> <update-name> <rel> <model-vars>
 &optional write-body)
(write-body-ldd-of-update <rel> <model-vars>)
// Also needs DAG test?

// For a M-H update:
(write-test-mh-update <class-name> <update-name>)

[write-test-file: (UNTESTED... but it's just "glue") 
- calls make-write-test-update-fct 
- calls write-test-updates]
[make-write-test-update-fct (UNTESTED... but it's mostly "glue")
- calls write-test-update]
[write-test-update (UNTESTED ... mostly "glue", sequencing)
- calls write-test-is-dag-update
- calls is-gibbs-update
- calls is-mh-update
- calls write-test-gibbs-update
- calls write-test-outer-lets-invariant
- calls write-test-acceptance-ratio (TODO)]

TestIsDAG_Update_ALPHA(x); (apply to Gibbs updates and proposal distr of M-H)
TestOuterLetsAreInvariant_ALPHA(x); (apply to M-H updates)
TestAcceptanceRatio_ALPHA(x, tol);


NEXT: Implement code for doing unit test of M-H updates.
General:
  [outer layers consisting of
   - lets: updates leave RHS unchanged
   - ifs: updates leave test unchanged
   - for: updates leave bounds unchanged]
  [Generate test for outer layer: test generates same code
   as impl itself, except that acceptance test is replaced
   by assertion that the relevant vars should be unchanged.]
  [inner layer: lets wrapped around a M-H rel.]
  [Generate test for inner layer: same code as impl itself,
   except that inner layer replaced by
   + evaluate LogJointDensity()
   - lets
   + evaluate proposal density

   - draw from proposal density
   - compute log acceptance ratio

   + evaluate LogJointDensity()
   + lets
   + evaluate proposal density

   - Compare lar to (ljd1 + lpd1 - ljd0 - lpd0)]
Additional test:
  [Test that M-H proposal distr is valid by checking that no value
   gets updated more than once.]

Take a closer look at test for Gibbs updates -- I'm not sure that it's correct,
in that it doesn't deal with the case where the draw depends on the variable
or variables being updated.


(:quant qand i (m n) (p i)) == (reduce-qand true (qvec i (m n) (p i)))

(:quant qor i (m n) (p i)) == (reduce-qor false (qvec i (m n) (p i)))

(:quant qmin i (m n) (f i)) == (reduce-qmin %infty+ (qvec i (m n) (p i)))

(:quant qmax i (m n) (f i)) == (reduce-qmax %infty- (qvec i (m n) (p i)))

(:quant qnum i (m n) (p i)) == (reduce-f 0 (qvec i (m n) (p i)))
where f(n, y) = n + bool-to-int(y)

(:quant qsum i (m n) (f i)) == (reduce-+ 0 (qvec i (m n) (f i)))
  
(:quant qprod i (m n) (f i)) == (reduce-* 0 (qvec i (m n) (f i)))

(:quant q@sum i (m n) (f i)) == (reduce-@+ (qvec i (m n) (f i))) if m <= n
                             == %undef                           otherwise ???

(:quant qmat i (m n) (f i)) == (reduce-cons-row ? (qvec i (m n) (f i)))

// These go in the test class

public void TestUpdate_FOO(MyModel x, double tol)
{
  x = x.Copy();
  x.Draw();
  MyModel x1 = x.Copy();
  x1.UpdateFromProposal_FOO();
  double expected =
    (LogProposalDensity_FOO(x) - LogProposalDensity_FOO(x1)) +
    (x1.LogJointDensity() - x0.LogJointDensity());
  double log_acceptance_ratio =
    x1.LogAcceptanceFactor_FOO() - x.LogAcceptanceFactor_FOO();
  Assert.AreEqual(expected, log_acceptance_ratio, tol, "FOO");  
}

public static double LogProposalDensity_FOO(MyModel x)
{
  ...
}


